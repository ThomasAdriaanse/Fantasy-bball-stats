{% extends "base.html" %}
{% block title %}Trade Value{% endblock %}

{% block head_extra %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
<style>
  :root {
    --bg: #0b0e14;
    --card: #10131a;
    --text: #e8eefc;
    --muted: #9fb2cf;
    --border: rgba(255, 255, 255, 0.10);
    --border-2: rgba(255, 255, 255, 0.18);
    --shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
  }

  .card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    box-shadow: var(--shadow);
    padding: 14px;
  }

  .body-container {
    max-width: 1400px;
    /* wider so names + z tables fit better */
    margin: 0 auto;
    padding: 14px 12px 32px;
  }

  /* ------- Form layout ------- */
  .trade-form {
    display: grid;
    grid-template-columns: 1fr;
    gap: 12px;
  }

  .sides-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }

  .side-card {
    border-radius: 12px;
    border: 1px solid var(--border);
    padding: 12px;
  }

  .side-title {
    font-weight: 700;
    opacity: .95;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .select-row {
    display: grid;
    grid-template-columns: 1fr;
    gap: 8px;
    margin-top: 10px;
  }

  .select-row .row-2 {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  label {
    font-size: 12px;
    opacity: .8;
    display: block;
    margin-bottom: 4px;
  }

  select {
    width: 100%;
    background: var(--bg);
    color: var(--text);
    border: 1px solid var(--border-2);
    border-radius: 8px;
    padding: 8px 10px;
  }

  .window-row {
    display: flex;
    gap: 10px;
    align-items: end;
  }

  .window-row .spacer {
    flex: 1;
  }

  .btn {
    background: #0b0e14;
    color: var(--text);
    border: 1px solid var(--border-2);
    border-radius: 8px;
    padding: 9px 14px;
    cursor: pointer;
  }

  .btn:hover {
    filter: brightness(1.06);
  }

  @media (max-width: 820px) {
    .sides-grid {
      grid-template-columns: 1fr;
    }

    .select-row .row-2 {
      grid-template-columns: 1fr;
    }
  }

  /* ------- Summary chips ------- */
  .summary-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-top: 10px;
  }

  .sum-box {
    padding: 10px 12px;
    border-radius: 10px;
    border: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .sum-a {
    box-shadow: inset 0 0 0 1px rgba(70, 130, 180, .35);
  }

  .sum-b {
    box-shadow: inset 0 0 0 1px rgba(255, 72, 72, .35);
  }

  .sum-title {
    font-weight: 700;
  }

  .sum-sub {
    font-size: 12px;
    opacity: .85;
  }

  /* ------- Tables ------- */
  table {
    width: 100%;
    border-collapse: collapse;
  }

  th,
  td {
    border-bottom: 1px solid var(--border);
    padding: 8px 10px;
    white-space: nowrap;
    font-size: 14px;
  }

  thead th {
    background: #121722;
    text-align: center;
  }

  td:first-child,
  th:first-child {
    text-align: left;
  }

  /* Player z-color cells */
  .zcell {
    text-align: center;
    color: #fff;
    text-shadow: 0 1px 2px rgba(0, 0, 0, .35);
  }

  .player-tables {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    align-items: flex-start;
  }

  /* keep both sides equal-width, prevent clipping */
  .player-tables>div {
    min-width: 0;
    overflow-x: hidden;
  }

  .player-tables table {
    table-layout: fixed;
    width: 100%;
  }

  .player-tables th,
  .player-tables td {
    overflow: hidden;
    text-overflow: ellipsis;
  }

  @media (max-width: 980px) {
    .player-tables {
      grid-template-columns: 1fr;
    }
  }

  /* ------- Radar block ------- */
  .viz-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 12px;
  }

  #radar svg {
    width: 100%;
    height: 420px;
    display: block;
  }

  /* ------- Difference bars (A − B) ------- */
  .dz-title {
    font-weight: 700;
    margin-bottom: 4px;
  }

  #dz-chart svg {
    width: 100%;
    height: 360px;
    display: block;
  }

  .dz-axis line,
  .dz-axis path {
    stroke: rgba(255, 255, 255, 0.22);
  }

  .dz-axis text {
    fill: var(--text);
    font-size: 12px;
  }

  .dz-baseline {
    stroke: rgba(255, 255, 255, 0.35);
    stroke-width: 1.2;
  }

  .dz-bar {
    shape-rendering: crispEdges;
  }

  .dz-label {
    fill: var(--text);
    font-size: 11px;
    text-anchor: middle;
  }

  .dz-xlab {
    fill: var(--muted);
    font-size: 11px;
    text-anchor: end;
  }

  .dz-ylab {
    fill: var(--muted);
    text-anchor: middle;
    font-size: 11px;
  }

  /* ------- Overall difference chip ------- */
  .overall-wrap {
    margin-top: 12px;
    display: flex;
    justify-content: center;
  }

  .overall-pill {
    display: inline-flex;
    gap: 10px;
    align-items: center;
    padding: 10px 14px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(255, 255, 255, 0.04);
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06);
    font-weight: 700;
    color: var(--text);
  }

  .overall-amt {
    font-size: 13px;
    padding: 4px 8px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.06);
  }

  .amt-pos {
    color: #9fe6a1;
  }

  .amt-neg {
    color: #ff9a9a;
  }

  /* ------- Trade PMF panel ------- */
  .pmf-card {
    margin-top: 12px;
  }

  .pmf-card h3 {
    text-align: center;
  }

  .pmf-subtitle {
    font-weight: 700;
    font-size: 13px;
    margin: 2px 0 6px;
    color: var(--muted);
    text-align: center;
  }

  .pmf-summary-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 8px;
    font-size: 13px;
    table-layout: fixed;
  }

  .pmf-summary-table th,
  .pmf-summary-table td {
    border-bottom: 1px solid var(--border);
    padding: 6px 8px;
    text-align: center;
    /* all centered now */
    white-space: nowrap;
  }

  /* column sizing for summary table */
  .pmf-summary-table th.col-team,
  .pmf-summary-table td.col-team {
    width: 16%;
  }

  .pmf-summary-table th.col-delta,
  .pmf-summary-table td.col-delta {
    width: 8%;
  }

  .pmf-summary-table th.col-cat,
  .pmf-summary-table td.col-cat {
    width: 12%;
  }

  .pmf-summary-table tr.pmf-summary-total td {
    font-weight: 700;
    border-top: 1px solid var(--border-2);
  }

  .pmf-grid {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: 12px;
  }

  /* label between the two charts */
  .pmf-row {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: 8px;
    align-items: center;
  }

  .pmf-cat-label {
    font-size: 13px;
    font-weight: 600;
    text-align: center;
    color: var(--muted);
    padding: 0 4px;
  }

  .pmf-chart-box {
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 4px 6px 6px;
    background: #0b0e14;
  }

  .pmf-chart-title {
    font-size: 11px;
    color: var(--muted);
    margin-bottom: 2px;
    text-align: left;
  }

  .pmf-chart {
    width: 100%;
    height: 120px;
  }

  .pmf-legend {
    margin-top: 6px;
    display: flex;
    gap: 12px;
    font-size: 11px;
    color: var(--muted);
  }

  .pmf-legend-swatch {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 2px;
    margin-right: 4px;
  }

  /* Player typeahead selector */
  .player-typeahead-wrap {
    position: relative;
  }

  .player-typeahead-wrap input[type="text"] {
    width: 100%;
    background: var(--bg);
    color: var(--text);
    border: 1px solid var(--border-2);
    border-radius: 8px;
    padding: 8px 10px;
  }

  .player-typeahead-wrap input[type="text"]:focus {
    outline: none;
    border-color: rgba(255, 255, 255, 0.35);
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.35);
  }

  .player-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    margin-top: 4px;
    max-height: 260px;
    overflow-y: auto;
    background: var(--card);
    border: 1px solid var(--border-2);
    border-radius: 8px;
    box-shadow: var(--shadow);
    z-index: 20;
  }

  .player-option {
    padding: 8px 10px;
    font-size: 14px;
    cursor: pointer;
    color: var(--text);
    background: var(--card);
  }

  .player-option:hover {
    background: rgba(255, 255, 255, .06);
  }

  .player-option.active {
    background: rgba(70, 130, 180, 0.35);
  }

  /* Toggle Switch */
  .switch input { 
    opacity: 0;
    width: 0;
    height: 0;
  }
  .switch input:checked + .slider {
    background-color: #4ea4ff;
  }
  .switch input:focus + .slider {
    box-shadow: 0 0 1px #4ea4ff;
  }
  .switch input:checked + .slider .slider-knob {
    transform: translateX(16px);
  }
</style>
<script src="https://d3js.org/d3.v7.min.js"></script>
{% endblock head_extra %}

{% block content %}
<div class="body-container">

  <!-- FORM -->
  <form class="card trade-form" method="POST" action="{{ url_for('trades.trade_analyzer') }}">
    <div class="sides-grid">
      <!-- Side A -->
      <div class="side-card">
        <div class="side-title">
          <div>Side A</div>
          <div style="font-size:small;">Players that will be on Team A after the trade</div>
        </div>
        <div class="select-row">
          <div class="row-2">
            <div>
              <label for="a1">Player 1</label>
              <div class="player-typeahead-wrap">
                <input id="a1" name="a1" type="text" value="{{ side_a[0] if side_a[0] else '' }}" autocomplete="off" />
                <div class="player-dropdown"></div>
              </div>
            </div>
            <div>
              <label for="a2">Player 2</label>
              <div class="player-typeahead-wrap">
                <input id="a2" name="a2" type="text" value="{{ side_a[1] if side_a[1] else '' }}" autocomplete="off" />
                <div class="player-dropdown"></div>
              </div>
            </div>
          </div>
          <div class="row-2">
            <div>
              <label for="a3">Player 3</label>
              <div class="player-typeahead-wrap">
                <input id="a3" name="a3" type="text" value="{{ side_a[2] if side_a[2] else '' }}" autocomplete="off" />
                <div class="player-dropdown"></div>
              </div>
            </div>
            <div>
              <label for="a4">Player 4</label>
              <div class="player-typeahead-wrap">
                <input id="a4" name="a4" type="text" value="{{ side_a[3] if side_a[3] else '' }}" autocomplete="off" />
                <div class="player-dropdown"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Side B -->
      <div class="side-card">
        <div class="side-title">
          <div>Side B</div>
          <div style="font-size:small;">Players that will be on Team B after the trade</div>
        </div>
        <div class="select-row">
          <div class="row-2">
            <div>
              <label for="b1">Player 1</label>
              <div class="player-typeahead-wrap">
                <input id="b1" name="b1" type="text" value="{{ side_b[0] if side_b[0] else '' }}" autocomplete="off" />
                <div class="player-dropdown"></div>
              </div>
            </div>
            <div>
              <label for="b2">Player 2</label>
              <div class="player-typeahead-wrap">
                <input id="b2" name="b2" type="text" value="{{ side_b[1] if side_b[1] else '' }}" autocomplete="off" />
                <div class="player-dropdown"></div>
              </div>
            </div>
          </div>
          <div class="row-2">
            <div>
              <label for="b3">Player 3</label>
              <div class="player-typeahead-wrap">
                <input id="b3" name="b3" type="text" value="{{ side_b[2] if side_b[2] else '' }}" autocomplete="off" />
                <div class="player-dropdown"></div>
              </div>
            </div>
            <div>
              <label for="b4">Player 4</label>
              <div class="player-typeahead-wrap">
                <input id="b4" name="b4" type="text" value="{{ side_b[3] if side_b[3] else '' }}" autocomplete="off" />
                <div class="player-dropdown"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Trading teams selector -->
    <div class="card" style="margin-top:10px; padding:10px 12px;">
      <div style="font-weight:700; margin-bottom:6px;">Trading teams</div>
      <div class="sides-grid">
        <div>
          <label for="team_a_idx">Team A</label>
          <select id="team_a_idx" name="team_a_idx">
            <option value="">Select Team A</option>
            {% for t in team_options %}
            <option value="{{ t.idx }}" {% if team_a_idx is not none and team_a_idx==t.idx %}selected{% endif %}>
              {{ t.name }}
            </option>
            {% endfor %}
          </select>
        </div>
        <div>
          <label for="team_b_idx">Team B</label>
          <select id="team_b_idx" name="team_b_idx">
            <option value="">Select Team B</option>
            {% for t in team_options %}
            <option value="{{ t.idx }}" {% if team_b_idx is not none and team_b_idx==t.idx %}selected{% endif %}>
              {{ t.name }}
            </option>
            {% endfor %}
          </select>
        </div>
      </div>
    </div>

    <!-- Window / action row -->
    <div class="window-row">
      <div>
        <label for="window">Stats (window)</label>
        <select id="window" name="window">
          {% for w in window_choices %}
          <option value="{{ w }}" {% if stat_window==w %}selected{% endif %}>{{ w }}</option>
          {% endfor %}
        </select>
      </div>
      <div class="spacer"></div>
      <button class="btn" type="submit">Evaluate</button>
    </div>
  </form>

  {% if results %}
  <!-- SUMMARY (Team Z-Score after selection) -->
  <div class="summary-grid">
    <div class="sum-box sum-a">
      <div>
        <div class="sum-title">Side A</div>
        <div class="sum-sub">Team Z-Score</div>
      </div>
      <div style="font-weight:700;">{{ '%.3f' % results.a_totals['_overall'] }}</div>
    </div>
    <div class="sum-box sum-b">
      <div>
        <div class="sum-title">Side B</div>
        <div class="sum-sub">Team Z-Score</div>
      </div>
      <div style="font-weight:700;">{{ '%.3f' % results.b_totals['_overall'] }}</div>
    </div>
  </div>

  <!-- PLAYER TABLES -->
  <div class="card" style="margin-top:12px;">
    {% set stats_count = categories|length + 1 %} {# categories + Total col #}
    {% set total_units = 2 + stats_count %}
    {% set unit = 100 / total_units %}
    <div class="player-tables">
      <div>
        <div style="font-weight:700; margin-bottom:6px;">Side A — Player Z-Scores</div>
        <table>
          <colgroup>
            <col style="width: {{ (2*unit)|round(2) }}%;">
            {% for _ in range(stats_count) %}
            <col style="width: {{ unit|round(2) }}%;">
            {% endfor %}
          </colgroup>
          <thead>
            <tr>
              <th>Player</th>
              {% for c in categories %}<th>{{ c }}</th>{% endfor %}
              <th>Total</th>
            </tr>
          </thead>
          <tbody>
            {% for row in results.a_players_rows %}
            <tr>
              <td>{{ row.player_name }}</td>
              {% set ns = namespace(total=0) %}
              {% for cell in row.cells %}
              {% set ns.total = ns.total + cell.z %}
              <td class="zcell" style="background: {{ cell.bg }};">{{ '%.2f' % cell.z }}</td>
              {% endfor %}
              <td class="zcell">{{ '%.2f' % ns.total }}</td>
            </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>

      <div>
        <div style="font-weight:700; margin-bottom:6px;">Side B — Player Z-Scores</div>
        <table>
          <colgroup>
            <col style="width: {{ (2*unit)|round(2) }}%;">
            {% for _ in range(stats_count) %}
            <col style="width: {{ unit|round(2) }}%;">
            {% endfor %}
          </colgroup>
          <thead>
            <tr>
              <th>Player</th>
              {% for c in categories %}<th>{{ c }}</th>{% endfor %}
              <th>Total</th>
            </tr>
          </thead>
          <tbody>
            {% for row in results.b_players_rows %}
            <tr>
              <td>{{ row.player_name }}</td>
              {% set ns = namespace(total=0) %}
              {% for cell in row.cells %}
              {% set ns.total = ns.total + cell.z %}
              <td class="zcell" style="background: {{ cell.bg }};">{{ '%.2f' % cell.z }}</td>
              {% endfor %}
              <td class="zcell">{{ '%.2f' % ns.total }}</td>
            </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- DIFFERENCE (A − B) and RADAR side-by-side -->
  <div class="card" style="margin-top:12px;">
    <div style="display:flex; flex-wrap:wrap; gap:20px;">
      
      <!-- Left: Difference Chart -->
      <div style="flex:1; min-width:500px;">
        <div class="dz-title">Difference in Team Z-Score by Category (Side A − Side B)</div>
        <div id="dz-chart"></div>

        {% set overall_diff = results.a_totals['_overall'] - results.b_totals['_overall'] %}
        <div class="overall-wrap">
          <div class="overall-pill">
            <div>Overall Difference in Team Z-Score (Side A − Side B)</div>
            <div class="overall-amt {{ 'amt-pos' if overall_diff>=0 else 'amt-neg' }}">
              {{ '+' if overall_diff>=0 else '' }}{{ '%.2f' % overall_diff }}
            </div>
          </div>
        </div>
      </div>

      <!-- Right: Radar -->
      <div style="flex:1; min-width:400px; display:flex; justify-content:center; align-items:center;">
        <div id="radar" style="width:100%; max-width:600px;"></div>
      </div>

    </div>
  </div>

  <!-- TRADE PMF / WIN% PANEL -->
  <div class="card pmf-card">
    <h3 style="margin-top:0;">Trade impact (PMFs & average win%)</h3>
    <div class="pmf-subtitle">Leaguewide Category Comparison Graphs</div>

    <!-- Toggle for Win% / Stats -->
    <div style="display:flex; justify-content:center; margin-bottom:10px;">
      <div class="toggle-container" style="display:flex; align-items:center; gap:8px; background:rgba(255,255,255,0.05); padding:4px 8px; border-radius:20px; border:1px solid var(--border);">
        <span id="label-win" style="font-size:12px; font-weight:600; color:#fff; cursor:pointer;">Win %</span>
        <label class="switch" style="position:relative; display:inline-block; width:34px; height:18px;">
          <input type="checkbox" id="stats-toggle">
          <span class="slider round" style="position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background-color:#4682b4; transition:.4s; border-radius:34px;"></span>
          <span class="slider-knob" style="position:absolute; content:''; height:12px; width:12px; left:3px; bottom:3px; background-color:white; transition:.4s; border-radius:50%;"></span>
        </label>
        <span id="label-stats" style="font-size:12px; font-weight:600; color:var(--muted); cursor:pointer;">Stats</span>
      </div>
    </div>

    <!-- Summary win% table -->
    <div id="trade-pmf-summary"></div>

    <!-- 2-column PMF grid (before / after) -->
    <div class="pmf-grid" id="trade-pmf-grid"></div>

    <!-- Legend -->
    <div class="pmf-legend">
      <div><span class="pmf-legend-swatch" style="background:#4ea4ff;"></span>Trading team (Side A)</div>
      <div><span class="pmf-legend-swatch" style="background:#ff7070;"></span>Trading team (Side B)</div>
      <div><span class="pmf-legend-swatch" style="background:rgba(255,255,255,0.45);"></span>Other teams</div>
    </div>
  </div>

  {% endif %}
</div>
{% endblock content %}

{% block body_js %}

<script>
  // ===========================
  // Player typeahead for all 8 inputs
  // ===========================
  (function () {
    const playerNames = {{ player_names | tojson
  }};
  const players = playerNames.map(name => ({ full_name: name }));
  const inputIds = ['a1', 'a2', 'a3', 'a4', 'b1', 'b2', 'b3', 'b4'];

  inputIds.forEach(inputId => {
    const input = document.getElementById(inputId);
    if (!input) return;
    const wrap = input.closest('.player-typeahead-wrap');
    if (!wrap) return;
    const dropdown = wrap.querySelector('.player-dropdown');
    if (!dropdown) return;

    let activeIndex = -1;

    function clearActive(options) {
      options.forEach(opt => opt.classList.remove("active"));
    }

    function setActive(index) {
      const options = dropdown.querySelectorAll(".player-option");
      if (!options.length) {
        activeIndex = -1;
        return;
      }
      if (index < 0) index = 0;
      if (index >= options.length) index = options.length - 1;
      clearActive(options);
      options[index].classList.add("active");
      activeIndex = index;

      const el = options[index];
      const elTop = el.offsetTop;
      const elBottom = elTop + el.offsetHeight;
      const viewTop = dropdown.scrollTop;
      const viewBottom = viewTop + dropdown.clientHeight;
      if (elTop < viewTop) {
        dropdown.scrollTop = elTop;
      } else if (elBottom > viewBottom) {
        dropdown.scrollTop = elBottom - dropdown.clientHeight;
      }
    }

    function renderOptions(query) {
      const q = query.trim().toLowerCase();
      dropdown.innerHTML = "";
      activeIndex = -1;
      if (!q) {
        dropdown.style.display = "none";
        return;
      }
      const matches = players
        .filter(p => (p.full_name || "").toLowerCase().includes(q))
        .slice(0, 40);
      if (!matches.length) {
        dropdown.style.display = "none";
        return;
      }
      matches.forEach(p => {
        const opt = document.createElement("div");
        opt.className = "player-option";
        opt.textContent = p.full_name;
        opt.addEventListener("mousedown", function (e) {
          e.preventDefault();
          input.value = p.full_name;
          dropdown.style.display = "none";
        });
        dropdown.appendChild(opt);
      });
      dropdown.style.display = "block";
      setActive(0);
    }

    input.addEventListener("input", function () {
      renderOptions(input.value);
    });

    input.addEventListener("focus", function () {
      if (input.value) renderOptions(input.value);
    });

    input.addEventListener("keydown", function (e) {
      const options = dropdown.querySelectorAll(".player-option");
      const hasOptions = options.length > 0;

      if (e.key === "ArrowDown" && hasOptions) {
        e.preventDefault();
        if (activeIndex === -1) {
          setActive(0);
        } else {
          setActive(activeIndex + 1);
        }
      } else if (e.key === "ArrowUp" && hasOptions) {
        e.preventDefault();
        if (activeIndex === -1) {
          setActive(0);
        } else {
          setActive(activeIndex - 1);
        }
      } else if (e.key === "Enter" && hasOptions && activeIndex !== -1) {
        e.preventDefault();
        const chosen = options[activeIndex];
        if (chosen) {
          input.value = chosen.textContent;
          dropdown.style.display = "none";
        }
      } else if (e.key === "Escape") {
        dropdown.style.display = "none";
        activeIndex = -1;
      }
    });

    document.addEventListener("click", function (e) {
      if (e.target !== input && !dropdown.contains(e.target)) {
        dropdown.style.display = "none";
        activeIndex = -1;
      }
    });
  });
  }) ();
</script>

{% if results %}
<script>
  (function () {
    /* ---------- Radar ---------- */
    const cats = {{ categories | tojson
  }};
  const A = {{ results.a_totals | tojson }};
  const B = {{ results.b_totals | tojson }};
  const capRadar = 3;
  const norm = (v) => Math.max(0, Math.min(1, (v + capRadar) / (2 * capRadar)));

  const dataA = cats.map(c => ({ axis: c, val: norm(A[c]) }));
  const dataB = cats.map(c => ({ axis: c, val: norm(B[c]) }));

  const wrapR = d3.select("#radar");
  const wR = wrapR.node().clientWidth || 600, hR = 420, rPad = 50;
  const cx = wR / 2, cy = hR / 2, radius = Math.min(wR, hR) / 2 - rPad;
  const angle = (i) => (i / cats.length) * 2 * Math.PI;
  const r = d3.scaleLinear().domain([0, 1]).range([0, radius]);

  const svgR = wrapR.append("svg").attr("viewBox", `0 0 ${wR} ${hR}`);
  const gR = svgR.append("g").attr("transform", `translate(${cx},${cy})`);

  const rings = [0.25, 0.5, 0.75, 1];
  gR.selectAll(".grid")
    .data(rings).enter().append("circle")
    .attr("r", d => r(d))
    .attr("fill", "none").attr("stroke", "rgba(255,255,255,.18)");

  const axes = gR.selectAll(".axis")
    .data(cats).enter().append("g").attr("class", "axis");

  axes.append("line")
    .attr("x1", 0).attr("y1", 0)
    .attr("x2", (d, i) => Math.cos(angle(i)) * radius)
    .attr("y2", (d, i) => Math.sin(angle(i)) * radius)
    .attr("stroke", "rgba(255,255,255,.22)");

  axes.append("text")
    .attr("x", (d, i) => Math.cos(angle(i)) * (radius + 12))
    .attr("y", (d, i) => Math.sin(angle(i)) * (radius + 12))
    .attr("text-anchor", (d, i) => {
      const a = Math.cos(angle(i));
      return a > 0.15 ? "start" : (a < -0.15 ? "end" : "middle");
    })
    .style("font-size", "12px").style("fill", "#e8eefc")
    .text(d => d);

  function polyPath(data) {
    const points = data.map((d, i) => {
      const a = angle(i), rr = r(d.val);
      return [Math.cos(a) * rr, Math.sin(a) * rr];
    });
    return d3.line().curve(d3.curveCardinalClosed.tension(0.6))(points);
  }

  gR.append("path").attr("d", polyPath(dataA))
    .attr("fill", "rgba(70,130,180,0.25)").attr("stroke", "steelblue").attr("stroke-width", 2);

  gR.append("path").attr("d", polyPath(dataB))
    .attr("fill", "rgba(255,72,72,0.25)").attr("stroke", "red").attr("stroke-width", 2);


  /* ---------- Difference bars: (Side A − Side B) per category ---------- */
  const W = (d3.select("#dz-chart").node().clientWidth || 1000);
  const H = 360;
  const m = { top: 20, right: 20, bottom: 70, left: 68 };
  const innerW = W - m.left - m.right;
  const innerH = H - m.top - m.bottom;

  const dzData = cats.map(c => ({
    cat: c,
    z: (+A[c] || 0) - (+B[c] || 0)
  }));

  const svg = d3.select("#dz-chart").append("svg").attr("viewBox", `0 0 ${W} ${H}`);
  const g = svg.append("g").attr("transform", `translate(${m.left},${m.top})`);

  const cap = 4;
  const zMin = d3.min(dzData, d => d.z);
  const zMax = d3.max(dzData, d => d.z);
  const baseMin = Math.min(-0.5, Math.max(-cap, Math.floor(zMin * 10) / 10));
  const baseMax = Math.max(0.5, Math.min(cap, Math.ceil(zMax * 10) / 10));
  const yPad = Math.max(0.2, (baseMax - baseMin) * 0.06);

  const x = d3.scaleBand()
    .domain(dzData.map(d => d.cat))
    .range([0, innerW])
    .padding(0.20);

  const y = d3.scaleLinear()
    .domain([baseMin - yPad, baseMax + yPad])
    .nice()
    .range([innerH, 0]);

  function zColor(z) {
    if (!isFinite(z)) return "rgba(255,255,255,0.25)";
    const t = Math.max(0, Math.min(1, (z + cap) / (2 * cap)));
    const hue = 120 * t;
    return `hsl(${hue}, 70%, 45%)`;
  }

  g.append("g")
    .attr("class", "dz-axis")
    .attr("transform", `translate(0,${y(0)})`)
    .append("line")
    .attr("class", "dz-baseline")
    .attr("x1", 0).attr("x2", innerW).attr("y1", 0).attr("y2", 0);

  g.append("g").attr("class", "dz-axis").call(d3.axisLeft(y).ticks(6));
  g.append("g")
    .attr("class", "dz-axis")
    .attr("transform", `translate(0,${innerH})`)
    .call(d3.axisBottom(x))
    .selectAll("text")
    .attr("class", "dz-xlab")
    .attr("transform", "rotate(-35)")
    .style("text-anchor", "end");

  g.append("text")
    .attr("class", "dz-ylab")
    .attr("transform", "rotate(-90)")
    .attr("x", -innerH / 2)
    .attr("y", -50)
    .text("Difference in Team Z-Score (Side A − Side B)");

  g.selectAll(".dz-bar")
    .data(dzData)
    .enter()
    .append("rect")
    .attr("class", "dz-bar")
    .attr("x", d => x(d.cat))
    .attr("width", x.bandwidth())
    .attr("y", d => d.z >= 0 ? y(d.z) : y(0))
    .attr("height", d => Math.max(2, Math.abs(y(d.z) - y(0))))
    .attr("fill", d => zColor(d.z));

  g.selectAll(".dz-label")
    .data(dzData)
    .enter()
    .append("text")
    .attr("class", "dz-label")
    .attr("x", d => x(d.cat) + x.bandwidth() / 2)
    .attr("y", d => d.z >= 0 ? (y(d.z) - 10) : (y(d.z) + 16))
    .text(d => isFinite(d.z) ? d.z.toFixed(2) : '—');

  }) ();
</script>

<script>
  (function () {
    const pmfResult = {{ pmf_result | tojson | safe if pmf_result else 'null'
  }};
  if (!pmfResult) {
    console.log("[TRADE-PMF][JS] pmfResult is null");
    return;
  }

  console.log("[TRADE-PMF][JS] pmfResult:", pmfResult);

  const cats = pmfResult.categories || [];
  const teamsMeta = pmfResult.teams || [];
  const before = pmfResult.before || {};
  const after = pmfResult.after || {};
  const trading = pmfResult.trading_teams || {};

  const sideAId = trading.team_a_idx;
  const sideBId = trading.team_b_idx;

  console.log("[TRADE-PMF][JS] trading teams A,B =", sideAId, sideBId);

  const teamById = new Map();
  (teamsMeta || []).forEach(t => {
    // Assume trade_pmf_eval sets team_idx to team_id as requested
    teamById.set(String(t.team_idx), t);
  });

  // ---------- 3.1 Summary win% table ----------

  // ---------- 3.1 Summary table (Win % OR Stats) ----------
  const winBefore = before.avg_win_pct || {};
  const winAfter = after.avg_win_pct || {};
  const statsBefore = before.avg_stats || {};
  const statsAfter = after.avg_stats || {};

  function getValue(dict, teamId, cat) {
    if (teamId === null || teamId === undefined) return null;
    const key = String(teamId);
    const row = dict[key] || {};
    const v = row[cat];
    return (v == null || isNaN(v)) ? null : Number(v);
  }

  const tA = teamById.get(String(sideAId));
  const tB = teamById.get(String(sideBId));

  function renderSummaryTable(mode) {
    // mode: 'win' or 'stats'
    const isStats = (mode === 'stats');
    const dictBefore = isStats ? statsBefore : winBefore;
    const dictAfter = isStats ? statsAfter : winAfter;

    const tblWrap = d3.select("#trade-pmf-summary");
    tblWrap.html("");
    const table = tblWrap.append("table").attr("class", "pmf-summary-table");
    const thead = table.append("thead").append("tr");

    thead.append("th").attr("class", "col-team").text(`${tA.team_name} before`);
    thead.append("th").attr("class", "col-delta").text("Δ");
    thead.append("th").attr("class", "col-team").text(`${tA.team_name} after`);
    thead.append("th").attr("class", "col-cat").text("Category");
    thead.append("th").attr("class", "col-team").text(`${tB.team_name} before`);
    thead.append("th").attr("class", "col-delta").text("Δ");
    thead.append("th").attr("class", "col-team").text(`${tB.team_name} after`);

    const tbody = table.append("tbody");

    // accumulators for summary row
    const aBeforeVals = [];
    const aAfterVals = [];
    const aDeltaVals = [];
    const bBeforeVals = [];
    const bAfterVals = [];
    const bDeltaVals = [];

    cats.forEach(cat => {
      const row = tbody.append("tr");

      const aBefore = getValue(dictBefore, sideAId, cat);
      const aAfter = getValue(dictAfter, sideAId, cat);
      const bBefore = getValue(dictBefore, sideBId, cat);
      const bAfter = getValue(dictAfter, sideBId, cat);

      // Formatting helper
      const fmt = (val) => {
        if (val == null) return "—";
        if (isStats) {
          // For stats: if cat is FG% or FT%, show 1 decimal + %. Else 1 decimal.
          if (cat === "FG%" || cat === "FT%") return val.toFixed(1) + "%";
          return val.toFixed(1);
        } else {
          // Win % always %
          return val.toFixed(1) + "%";
        }
      };

      // Team A before
      const cellABefore = row.append("td").attr("class", "col-team");
      cellABefore.text(fmt(aBefore));
      if (aBefore != null) aBeforeVals.push(aBefore);

      // Team A delta
      const cellADelta = row.append("td").attr("class", "col-delta");
      if (aBefore == null || aAfter == null) {
        cellADelta.text("—");
      } else {
        const delta = aAfter - aBefore;
        aDeltaVals.push(delta);
        const sign = delta >= 0 ? "+" : "";
        
        let txt = sign + delta.toFixed(1);
        if (!isStats || (cat === "FG%" || cat === "FT%")) txt += "%";
        
        cellADelta.text(txt);
        
        // Color logic
        let isGood = (delta >= 0);
        if (isStats && cat === "TO") isGood = (delta <= 0);
        
        cellADelta.style("color", isGood ? "#4ade80" : "#f87171");
        cellADelta.style("font-weight", "600");
      }

      // Team A after
      const cellAAfter = row.append("td").attr("class", "col-team");
      cellAAfter.text(fmt(aAfter));
      if (aAfter != null) aAfterVals.push(aAfter);

      // Category
      row.append("td").attr("class", "col-cat").text(cat);

      // Team B before
      const cellBBefore = row.append("td").attr("class", "col-team");
      cellBBefore.text(fmt(bBefore));
      if (bBefore != null) bBeforeVals.push(bBefore);

      // Team B delta
      const cellBDelta = row.append("td").attr("class", "col-delta");
      if (bBefore == null || bAfter == null) {
        cellBDelta.text("—");
      } else {
        const delta = bAfter - bBefore;
        bDeltaVals.push(delta);
        const sign = delta >= 0 ? "+" : "";
        
        let txt = sign + delta.toFixed(1);
        if (!isStats || (cat === "FG%" || cat === "FT%")) txt += "%";

        cellBDelta.text(txt);

        let isGood = (delta >= 0);
        if (isStats && cat === "TO") isGood = (delta <= 0);

        cellBDelta.style("color", isGood ? "#4ade80" : "#f87171");
        cellBDelta.style("font-weight", "600");
      }

      // Team B after
      const cellBAfter = row.append("td").attr("class", "col-team");
      cellBAfter.text(fmt(bAfter));
      if (bAfter != null) bAfterVals.push(bAfter);
    });

    // Summary row (only for Win%, stats average doesn't make sense across different units)
    if (!isStats) {
      const totalRow = tbody.append("tr").attr("class", "pmf-summary-total");
      
      const avg = (arr) => {
        const vals = arr.filter(v => v != null && !isNaN(v));
        if (!vals.length) return null;
        return vals.reduce((s, v) => s + v, 0) / vals.length;
      };

      const aBeforeAvg = avg(aBeforeVals);
      const aDeltaAvg = avg(aDeltaVals);
      const aAfterAvg = avg(aAfterVals);
      const bBeforeAvg = avg(bBeforeVals);
      const bDeltaAvg = avg(bDeltaVals);
      const bAfterAvg = avg(bAfterVals);

      // A Before
      totalRow.append("td").text(aBeforeAvg != null ? aBeforeAvg.toFixed(1) + "%" : "—");
      
      // A Delta
      const tdAD = totalRow.append("td");
      if (aDeltaAvg != null) {
        const sign = aDeltaAvg >= 0 ? "+" : "";
        tdAD.text(sign + aDeltaAvg.toFixed(1) + "%");
        tdAD.style("color", aDeltaAvg >= 0 ? "#4ade80" : "#f87171");
      } else {
        tdAD.text("—");
      }

      // A After
      totalRow.append("td").text(aAfterAvg != null ? aAfterAvg.toFixed(1) + "%" : "—");

      // Label
      totalRow.append("td").text("All cats (avg)");

      // B Before
      totalRow.append("td").text(bBeforeAvg != null ? bBeforeAvg.toFixed(1) + "%" : "—");

      // B Delta
      const tdBD = totalRow.append("td");
      if (bDeltaAvg != null) {
        const sign = bDeltaAvg >= 0 ? "+" : "";
        tdBD.text(sign + bDeltaAvg.toFixed(1) + "%");
        tdBD.style("color", bDeltaAvg >= 0 ? "#4ade80" : "#f87171");
      } else {
        tdBD.text("—");
      }

      // B After
      totalRow.append("td").text(bAfterAvg != null ? bAfterAvg.toFixed(1) + "%" : "—");
    }
  }

  if (tA && tB) {
    // Initial render: Win %
    renderSummaryTable('win');

    // Toggle logic
    const toggle = document.getElementById("stats-toggle");
    const labelWin = document.getElementById("label-win");
    const labelStats = document.getElementById("label-stats");

    if (toggle) {
      toggle.addEventListener("change", function() {
        const mode = this.checked ? 'stats' : 'win';
        renderSummaryTable(mode);
        
        // Update label colors
        if (mode === 'stats') {
          labelStats.style.color = "#fff";
          labelWin.style.color = "var(--muted)";
        } else {
          labelWin.style.color = "#fff";
          labelStats.style.color = "var(--muted)";
        }
      });
      
      // Click on labels to toggle
      labelWin.addEventListener("click", () => {
        if (toggle.checked) {
          toggle.checked = false;
          toggle.dispatchEvent(new Event('change'));
        }
      });
      labelStats.addEventListener("click", () => {
        if (!toggle.checked) {
          toggle.checked = true;
          toggle.dispatchEvent(new Event('change'));
        }
      });
    }

  } else {
    console.warn("[TRADE-PMF][JS] Could not resolve trading teams in teamById");
  }

  // ---------- 3.2 PMF charts grid (before / after) ----------
  const grid = d3.select("#trade-pmf-grid");
  if (grid.empty()) {
    console.warn("[TRADE-PMF][JS] #trade-pmf-grid missing");
    return;
  }
  grid.html("");

  const beforePmfs = (before.pmfs || {});
  const afterPmfs = (after.pmfs || {});

  const before1d = beforePmfs["1d"] || {};
  const before2d = beforePmfs["2d"] || {};
  const after1d = afterPmfs["1d"] || {};
  const after2d = afterPmfs["2d"] || {};

  function buildRow(cat) {
    const rowDiv = grid.append("div").attr("class", "pmf-row");

    const beforeBox = rowDiv.append("div").attr("class", "pmf-chart-box");
    beforeBox.append("div")
      .attr("class", "pmf-chart-title")
      .text("Before trade");
    const beforeChart = beforeBox.append("div")
      .attr("class", "pmf-chart")
      .attr("id", `pmf-before-${cat.replace('%', 'pct')}`);

    rowDiv.append("div")
      .attr("class", "pmf-cat-label")
      .text(cat);

    const afterBox = rowDiv.append("div").attr("class", "pmf-chart-box");
    afterBox.append("div")
      .attr("class", "pmf-chart-title")
      .text("After trade");
    const afterChart = afterBox.append("div")
      .attr("class", "pmf-chart")
      .attr("id", `pmf-after-${cat.replace('%', 'pct')}`);

    return {
      beforeId: beforeChart.attr("id"),
      afterId: afterChart.attr("id"),
    };
  }

  function teamStroke(teamId) {
    teamId = String(teamId);
    if (String(sideAId) === teamId) return "#4ea4ff";
    if (String(sideBId) === teamId) return "#ff7070";
    return "rgba(255,255,255,0.55)";
  }
  function teamFill(teamId) {
    teamId = String(teamId);
    if (String(sideAId) === teamId) return "rgba(78,164,255,0.25)";
    if (String(sideBId) === teamId) return "rgba(255,112,112,0.25)";
    return "rgba(255,255,255,0.12)";
  }

  function drawPanel(divId, cat, pmfList, isPctCat) {
    const el = document.getElementById(divId);
    if (!el) return;
    if (!Array.isArray(pmfList) || !pmfList.length) {
      console.warn("[TRADE-PMF][JS] No PMF list for", cat, "in", divId);
      return;
    }

    const container = d3.select(el);
    const w = container.node().clientWidth || 420;
    const h = container.node().clientHeight || 120;
    const margin = { top: 10, right: 8, bottom: 20, left: 32 };
    const innerW = w - margin.left - margin.right;
    const innerH = h - margin.top - margin.bottom;

    const allSeries = [];
    pmfList.forEach(entry => {
      const tid = String(entry.team_idx);
      const p = entry.pmf || {};
      if (!p || !Array.isArray(p.probs) || !p.probs.length) return;

      const min = Number(p.min) || 0;
      const series = p.probs.map((prob, i) => {
        const rawX = min + i;
        const xVal = isPctCat ? rawX / 10.0 : rawX;
        return { x: xVal, y: Number(prob), teamId: tid };
      });
      allSeries.push(series);
    });

    if (!allSeries.length) {
      console.warn("[TRADE-PMF][JS] allSeries empty for", cat, "in", divId);
      return;
    }

    const xMin = d3.min(allSeries, s => d3.min(s, d => d.x));
    const xMax = d3.max(allSeries, s => d3.max(s, d => d.x));

    const x = d3.scaleLinear()
      .domain([xMin, xMax])
      .range([0, innerW]);

    const y = d3.scaleLinear()
      .domain([0, 0.10])
      .range([innerH, 0]);

    const svg = container.append("svg")
      .attr("width", w)
      .attr("height", h);

    const g = svg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const xAxis = d3.axisBottom(x)
      .ticks(Math.min(6, Math.max(3, Math.floor(innerW / 60))))
      .tickSizeOuter(0)
      .tickFormat(d => {
        if (!isPctCat) return d3.format("~g")(d);
        return Math.round(d) + "%";
      });

    g.append("g")
      .attr("transform", `translate(0,${innerH})`)
      .call(xAxis)
      .style("color", "#8b949e");

    g.append("g")
      .call(d3.axisLeft(y).ticks(3).tickFormat(d3.format(".0%")))
      .style("color", "#8b949e");

    const area = d3.area()
      .x(d => x(d.x))
      .y0(innerH)
      .y1(d => y(d.y))
      .curve(d3.curveBasis);

    allSeries.forEach(series => {
      const tid = series[0].teamId;
      g.append("path")
        .datum(series)
        .attr("fill", teamFill(tid))
        .attr("stroke", teamStroke(tid))
        .attr(
          "stroke-width",
          (String(sideAId) === tid || String(sideBId) === tid) ? 1.8 : 0.9
        )
        .attr("d", area);
    });
  }

  cats.forEach(cat => {
    const isPctCat = (cat === "FG%" || cat === "FT%");
    const rowIds = buildRow(cat);

    const beforeList = isPctCat
      ? (before2d[cat] || [])
      : (before1d[cat] || []);

    const afterList = isPctCat
      ? (after2d[cat] || [])
      : (after1d[cat] || []);

    drawPanel(rowIds.beforeId, cat, beforeList, isPctCat);
    drawPanel(rowIds.afterId, cat, afterList, isPctCat);
  });

  }) ();
</script>
{% endif %}
{% endblock body_js %}