{% extends "base.html" %}
{% block title %}Player Stats · Fantasy BBall{% endblock %}

{% block head_extra %}
<script src="https://d3js.org/d3.v7.min.js"></script>
<link rel="stylesheet" href="{{ url_for('static', filename='css/player_stats.css') }}">
{% endblock head_extra %}

{% block content %}
<div class="body-container">
  <h1 style="font-size:28px">{{ selected_player }} — Moving Average {{ selected_stat }}</h1>

  <!-- Controls -->
  <div class="controls-card">
    <form method="POST" action="{{ url_for('players.player_stats') }}">
      <div class="controls-grid">
        <div>
          <label for="player_name">Select Player</label>
          <div class="player-typeahead-wrap">
            <input id="player_name" name="player_name" type="text" value="{{ selected_player }}" autocomplete="off" />
            <div id="player-dropdown" class="player-dropdown" style="display:none;"></div>
          </div>
        </div>

        <div>
          <label for="num_games">Moving Avg (games each side)</label>
          <input type="number" id="num_games" name="num_games" value="{{ num_games }}" min="1" />
        </div>

        <div>
          <label for="stat">Stat</label>
          <select id="stat" name="stat">
            {% for s in stat_options %}
            <option value="{{ s }}" {% if s==selected_stat %}selected{% endif %}>{{ s }}</option>
            {% endfor %}
          </select>
        </div>

        <div style="align-self:end;">
          <button class="btn" type="submit">Update</button>
        </div>
      </div>
    </form>
  </div>

  <!-- Chart -->
  <div class="chart-card">
    <div id="chart"></div>
    <div class="legend">
      <span><span class="swatch blue"></span> Moving Avg <span id="legend-stat">{{ selected_stat }}</span></span>
      <span><span class="swatch green"></span> Season Change</span>
      <span><span class="swatch red"></span> Team Change</span>
    </div>
  </div>

  <!-- PMF Section -->
  {% if pmf_data %}
  <div class="pmf-container">
    <div class="card pmf-combined-card">
      <h2 style="margin-top:0; border-left:none; padding-left:0; text-align:center;">Season Performance Distribution
        (2025-26)</h2>
      <div class="pmf-grid">
        {% for cat in ["PTS", "REB", "AST", "STL", "BLK", "3PM", "TO", "FG%", "FT%"] %}
        {% if pmf_data[cat] %}
        <div class="pmf-item">
          <h3>{{ cat }}</h3>
          <div id="pmf-chart-{{ cat | replace('%', '') }}" class="pmf-chart-container" data-cat="{{ cat }}"></div>
          <!-- Display Mean -->
          {% if pmf_data[cat].mean is defined %}
          <div class="pmf-mean">
            Average:
            {% if cat in ["FG%", "FT%"] %}
            {{ (pmf_data[cat].mean * 100)|round(1) }}%
            {% else %}
            {{ pmf_data[cat].mean|round(1) }}
            {% endif %}
          </div>
          {% endif %}
        </div>
        {% endif %}
        {% endfor %}
      </div>
    </div>
  </div>
  {% endif %}
</div>
{% endblock content %}

{% block body_js %}
<script>
  const params = new URLSearchParams({
    player_name: "{{ selected_player }}",
    num_games: "{{ num_games }}",
    stat: "{{ selected_stat }}"
  });

  const apiUrl = "{{ url_for('players.api_player_stats') }}";

  d3.json(`${apiUrl}?${params.toString()}`, { cache: "no-store" })
    .then(function (data) {
      if (!data || data.length === 0) {
        d3.select("#chart").append("p").text("No data available for this selection.");
        return;
      }

      const getVal = d =>
        (d.Centered_Avg_Value !== undefined ? +d.Centered_Avg_Value : +d.Centered_Avg_Stat);

      const statLabel =
        (data[0] && (data[0].STAT || "{{ selected_stat }}")) || "{{ selected_stat }}";

      d3.select("#legend-stat").text(statLabel);

      const margin = { top: 90, right: 50, bottom: 80, left: 90 },
        width = 2200 - margin.left - margin.right,
        height = 1100 - margin.top - margin.bottom;

      const svg = d3.select("#chart").append("svg")
        .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      const x = d3.scaleLinear()
        .domain([1, d3.max(data, d => +d.Game_Number)])
        .range([0, width]);

      const vals = data.map(getVal).filter(v => Number.isFinite(v));
      let minV = d3.min(vals), maxV = d3.max(vals);
      if (minV === maxV) {
        const pad = (Math.abs(maxV) || 1) * 0.1;
        minV -= pad;
        maxV += pad;
      }

      const labelUpper = statLabel.toUpperCase();
      const isZ = labelUpper.startsWith("Z_") || labelUpper === "AVG_Z";
      const isPctStat =
        !isZ && (/^(FG_PCT|FT_PCT|FG3_PCT)$/.test(labelUpper) || (maxV <= 1.2 && minV >= -0.1));

      let yDomain;
      if (isPctStat) {
        const pad = 0.03;
        yDomain = [Math.max(0, minV - pad), Math.min(1, maxV + pad)];
      } else {
        const spread = Math.max(1e-6, maxV - minV);
        const pad = spread * 0.1;
        yDomain = [minV - pad, maxV + pad];
        if (minV >= 0) yDomain[0] = 0;
      }

      const y = d3.scaleLinear()
        .domain(yDomain)
        .nice()
        .range([height, 0]);

      // X axis
      const xAxisG = svg.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x).ticks(12));

      xAxisG.selectAll("text").style("font-size", "24px");
      xAxisG.append("text")
        .attr("x", width / 2)
        .attr("y", 56)
        .attr("fill", "currentColor")
        .style("font-size", "20px")
        .attr("text-anchor", "middle")
        .text("Game Number");

      // Y axis (numeric ticks only)
      const yAxisG = svg.append("g").attr("class", "axis axis--y");
      const yAxis = d3.axisLeft(y).ticks(12);

      yAxisG.call(yAxis);
      yAxisG.selectAll("text").style("font-size", "24px");
      yAxisG.append("text")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", -68)
        .attr("fill", "currentColor")
        .style("font-size", "20px")
        .attr("text-anchor", "middle")
        .text(`Average ${statLabel}`);

      // Threshold dashes + labels (AVG_Z only; skip if off-chart)
      if (labelUpper === "AVG_Z") {
        const thresholds = [
          { value: 0.40, label: "Top 10" },
          { value: 0.10, label: "Top 50" },
          { value: -0.13, label: "Top 100" },
          { value: -0.31, label: "Top 150" }
        ];

        const threshGroup = svg.append("g").attr("class", "z-threshold-markers");

        thresholds.forEach(th => {
          const yVal = y(th.value);

          // If the mapped position is outside the drawable area, skip it
          if (yVal < 0 || yVal > height) {
            return;
          }

          // Left-side dash (just inside plot area)
          threshGroup.append("line")
            .attr("x1", 0)
            .attr("x2", 10)
            .attr("y1", yVal)
            .attr("y2", yVal)
            .attr("stroke", "#ff4d4d")
            .attr("stroke-width", 1.8)
            .attr("vector-effect", "non-scaling-stroke");

          // Left-side label
          threshGroup.append("text")
            .attr("x", 14)
            .attr("y", yVal + 4)
            .style("font-size", "16px")
            .style("fill", "#ff4d4d")
            .attr("text-anchor", "start")
            .text(th.label);

          // Right-side dash (just inside right edge so no clipping)
          const rightDashStart = width - 10;
          const rightDashEnd = width;

          threshGroup.append("line")
            .attr("x1", rightDashStart)
            .attr("x2", rightDashEnd)
            .attr("y1", yVal)
            .attr("y2", yVal)
            .attr("stroke", "#ff4d4d")
            .attr("stroke-width", 1.8)
            .attr("vector-effect", "non-scaling-stroke");

          // Right-side label (inside the chart area, aligned to the right)
          threshGroup.append("text")
            .attr("x", rightDashStart - 6)
            .attr("y", yVal + 4)
            .style("font-size", "16px")
            .style("fill", "#ff4d4d")
            .attr("text-anchor", "end")
            .text(th.label);
        });
      }

      const line = d3.line()
        .x(d => x(+d.Game_Number))
        .y(d => y(getVal(d)));

      svg.append("path")
        .datum(data)
        .attr("fill", "none")
        .attr("stroke", "steelblue")
        .attr("stroke-width", 2.2)
        .attr("vector-effect", "non-scaling-stroke")
        .attr("d", line);

      // Season boundaries
      const seasonKey = ("SEASON" in data[0])
        ? "SEASON"
        : (("SEASON_ID" in data[0]) ? "SEASON_ID" : null);

      if (seasonKey) {
        let prevSeason = String(data[0][seasonKey]);
        const boundaries = [];
        for (let i = 1; i < data.length; i++) {
          const s = String(data[i][seasonKey]);
          if (s !== prevSeason) {
            const label =
              ("SEASON" in data[i])
                ? String(data[i].SEASON)
                : (String(data[i].SEASON_ID).slice(-4) + "-" +
                  String((+String(data[i].SEASON_ID).slice(-4) + 1) % 100).padStart(2, "0"));
            boundaries.push({ g: +data[i].Game_Number, label });
            prevSeason = s;
          }
        }

        const seasonG = svg.append("g").attr("class", "season-lines");
        seasonG.selectAll("line")
          .data(boundaries)
          .enter()
          .append("line")
          .attr("x1", d => x(d.g))
          .attr("x2", d => x(d.g))
          .attr("y1", 0)
          .attr("y2", height)
          .attr("stroke", "#1bb01b")
          .attr("stroke-width", 1.6)
          .attr("vector-effect", "non-scaling-stroke")
          .attr("opacity", 0.9);

        seasonG.selectAll("text")
          .data(boundaries)
          .enter()
          .append("text")
          .attr("x", d => x(d.g))
          .attr("y", -16)
          .attr("text-anchor", "middle")
          .style("font-size", "16px")
          .text(d => d.label);
      }

      // Team change ticks
      const teamTicks = [];
      let lastTeam = null;

      data.forEach(d => {
        const currentTeam = (d.MATCHUP || "").split(" ")[0];
        if (lastTeam && currentTeam && lastTeam !== currentTeam) {
          teamTicks.push({ g: +d.Game_Number, y: getVal(d) });
        }
        if (currentTeam) lastTeam = currentTeam;
      });

      svg.append("g")
        .attr("class", "team-ticks")
        .selectAll("line")
        .data(teamTicks)
        .enter()
        .append("line")
        .attr("x1", d => x(d.g))
        .attr("x2", d => x(d.g))
        .attr("y1", d => y(d.y) - 8)
        .attr("y2", d => y(d.y) + 8)
        .attr("stroke", "red")
        .attr("stroke-width", 1.6)
        .attr("vector-effect", "non-scaling-stroke");
    })
    .catch(function () {
      d3.select("#chart").append("p").text("Failed to load data.");
    });
  // ===========================
  // Player typeahead selector
  // ===========================
  (function () {
    const input = document.getElementById("player_name");
    const dropdown = document.getElementById("player-dropdown");
    if (!input || !dropdown) return;

    const players = {{ players | tojson
  }};
  let activeIndex = -1;

  function submitForm() {
    const form = input.form;
    if (!form) return;
    if (form.requestSubmit) {
      form.requestSubmit();
    } else {
      form.submit();
    }
  }

  function clearActive(options) {
    options.forEach(opt => opt.classList.remove("active"));
  }

  function setActive(index) {
    const options = dropdown.querySelectorAll(".player-option");

    if (!options.length) {
      activeIndex = -1;
      return;
    }

    // clamp index to valid range
    if (index < 0) index = 0;
    if (index >= options.length) index = options.length - 1;

    clearActive(options);
    options[index].classList.add("active");
    activeIndex = index;

    // keep active option in view
    const el = options[index];
    const parent = dropdown;
    const elTop = el.offsetTop;
    const elBottom = elTop + el.offsetHeight;
    const viewTop = parent.scrollTop;
    const viewBottom = viewTop + parent.clientHeight;

    if (elTop < viewTop) {
      parent.scrollTop = elTop;
    } else if (elBottom > viewBottom) {
      parent.scrollTop = elBottom - parent.clientHeight;
    }
  }

  function renderOptions(query) {
    const q = query.trim().toLowerCase();
    dropdown.innerHTML = "";
    activeIndex = -1;

    if (!q) {
      dropdown.style.display = "none";
      return;
    }

    const matches = players
      .filter(p => (p.full_name || "").toLowerCase().includes(q))
      .slice(0, 40);

    if (!matches.length) {
      dropdown.style.display = "none";
      return;
    }

    matches.forEach(p => {
      const opt = document.createElement("div");
      opt.className = "player-option";
      opt.textContent = p.full_name;
      opt.addEventListener("mousedown", function (e) {
        e.preventDefault(); // keep focus on input
        input.value = p.full_name;
        dropdown.style.display = "none";
        submitForm();       // update immediately on click
      });
      dropdown.appendChild(opt);
    });

    dropdown.style.display = "block";
    // first option highlighted by default
    setActive(0);
  }

  input.addEventListener("input", function () {
    renderOptions(input.value);
  });

  input.addEventListener("focus", function () {
    if (input.value) renderOptions(input.value);
  });

  input.addEventListener("keydown", function (e) {
    const options = dropdown.querySelectorAll(".player-option");
    const hasOptions = options.length > 0;

    if (e.key === "ArrowDown" && hasOptions) {
      e.preventDefault();
      if (activeIndex === -1) {
        setActive(0);
      } else {
        setActive(activeIndex + 1);
      }
    } else if (e.key === "ArrowUp" && hasOptions) {
      e.preventDefault();
      if (activeIndex === -1) {
        setActive(0);
      } else {
        setActive(activeIndex - 1);
      }
    } else if (e.key === "Enter") {
      if (!hasOptions) {
        // no dropdown options; let Enter behave normally
        return;
      }
      if (activeIndex === -1) {
        // nothing is highlighted → do nothing special
        return;
      }
      e.preventDefault();

      const chosen = options[activeIndex];
      if (!chosen) return;

      input.value = chosen.textContent;
      dropdown.style.display = "none";
      submitForm();         // update immediately on Enter
    } else if (e.key === "Escape") {
      dropdown.style.display = "none";
      activeIndex = -1;
    }
  });

  document.addEventListener("click", function (e) {
    if (e.target !== input && !dropdown.contains(e.target)) {
      dropdown.style.display = "none";
      activeIndex = -1;
    }
  });
  }) ();

  // ===========================
  // PMF Charts (Season)
  // ===========================
  (function () {
    const pmfData = {{ pmf_data | tojson | safe
  }} || {};

  Object.keys(pmfData).forEach(cat => {
    const data = pmfData[cat];
    if (!data || !data.probs || data.probs.length === 0) return;

    const containerId = "pmf-chart-" + cat.replace('%', '');
    const container = document.getElementById(containerId);
    if (!container) return;

    const width = container.clientWidth;
    const height = container.clientHeight;
    const margin = { top: 15, right: 20, bottom: 35, left: 35 };
    const w = width - margin.left - margin.right;
    const h = height - margin.top - margin.bottom;

    const svg = d3.select(container).append("svg")
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Prepare Data
    let chartData = [];
    let isRatio = (cat === "FG%" || cat === "FT%");

    if (isRatio) {
      // Aggregate 0.1% buckets into 1% bins
      const binMap = new Map();

      data.probs.forEach((p, i) => {
        const valPct = (data.min + i) / 10.0;
        const bin = Math.floor(valPct);
        binMap.set(bin, (binMap.get(bin) || 0) + p);
      });

      const sortedBins = Array.from(binMap.keys()).sort((a, b) => a - b);
      if (sortedBins.length > 0) {
        const minBin = sortedBins[0];
        const maxBin = sortedBins[sortedBins.length - 1];
        for (let b = minBin; b <= maxBin; b++) {
          chartData.push({
            label: b + "%",
            value: binMap.get(b) || 0
          });
        }
      }
    } else {
      // Counting stats: 1-to-1 mapping
      data.probs.forEach((p, i) => {
        const val = data.min + i;
        chartData.push({
          label: val.toString(),
          value: p
        });
      });
    }

    // X Scale (Band scale centers bars on ticks)
    const x = d3.scaleBand()
      .domain(chartData.map(d => d.label))
      .range([0, w])
      .padding(0.1);

    // Y Scale
    const maxProb = d3.max(chartData, d => d.value) || 0.1;
    const y = d3.scaleLinear()
      .domain([0, maxProb * 1.05])
      .range([h, 0]);

    // Bars
    svg.selectAll(".pmf-bar")
      .data(chartData)
      .enter()
      .append("rect")
      .attr("class", "pmf-bar")
      .attr("x", d => x(d.label))
      .attr("y", d => y(d.value))
      .attr("width", x.bandwidth())
      .attr("height", d => h - y(d.value))
      // STYLING UPDATE here:
      .attr("fill", "rgba(70,130,180, 0.6)")
      .attr("stroke", "steelblue")
      .attr("stroke-width", 1);

    // X Axis
    let axis = d3.axisBottom(x);

    // Filter ticks if too many
    const domain = x.domain();
    if (domain.length > 15) {
      const step = Math.ceil(domain.length / 10);
      const visibleTicks = domain.filter((_, i) => i % step === 0);
      axis.tickValues(visibleTicks);
    }

    const xAxisG = svg.append("g")
      .attr("transform", `translate(0,${h})`)
      .call(axis);

    xAxisG.style("font-size", "10px")
      .style("color", "#8b949e"); // Axis color match

    xAxisG.selectAll("line").attr("stroke", "#8b949e");
    xAxisG.selectAll("path").attr("stroke", "#8b949e");

    // Y Axis
    const yAxis = d3.axisLeft(y).ticks(3).tickFormat(d3.format(".0%"));
    const yAxisG = svg.append("g")
      .call(yAxis);

    yAxisG.style("font-size", "10px")
      .style("color", "#8b949e"); // Axis color match

    yAxisG.selectAll("line").attr("stroke", "#8b949e");
    yAxisG.selectAll("path").attr("stroke", "#8b949e");

  });
  }) ();
</script>
{% endblock body_js %}